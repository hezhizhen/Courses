《操作系统教程》（第4版）

孙钟秀 主编

高等教育出版社(Higher Education Press)

======

#第一章 操作系统概论

###1.1 操作系统概观

#####1.1.1 操作系统的定义和目标

一般认为操作系统是：管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便而有效地使用计算机提供良好运行环境的最基本的系统软件。

OS的基本任务是：创建可供用户使用的抽象资源，管理这些资源的并发使用，为应用程序提供良好的运行环境。

OS的主要目标：

    (1)方便用户使用
    (2)扩充及其功能
    (3)管理各类资源
    (4)提高系统效率
    (5)构筑开放环境
    (OS遵循国际标准来设计和构造一个开放环境，其含义是指：遵循相关的国际工业标准和开放系统标准(如POSIX)；支持体系结构的可伸缩性和可扩展性；支持应用程序在不同平台上的可移植性和互操作性)

计算机系统：硬件+软件

计算机系统的软硬件层次结构：

    硬件层：提供基本的可计算性资源，包括处理器、寄存器、存储器及各种I/O设备。它们按照用户需求接收和存储信息、处理数据并输出运算结果
    操作系统层：最靠近硬件的软件层，负责管理和控制计算机硬件并对其做首次扩充和改造，主要做好资源的调度与分配、信息的存取与保护、并发活动的协调与控制等工作，把上层的支撑软件和应用软件与计算机硬件隔离开来，为其运行提供良好的基础和强有力的支撑
    支撑软件层：其工作基础建立在被OS扩充功能的机器上，利用系统所提供的扩展指令集，可以较容易地实现编译程序、汇编程序、语言处理程序、窗口系统、Internet浏览器、数据库管理系统和其他实用程序，支持应用软件的开发和运行。支撑软件通常可归入系统软件一类，但不属于OS的组成部分
    应用软件层：解决用户特定的或不同应用所需要的信息处理问题

OS与支撑软件和应用软件的区别：

    （都是程序，但意图不同）

    OS：有权分配资源
    其他程序：只能使用资源
    （两者是控制与被控制的关系）
    
    OS：直接作用于硬件之上，隔离其他上层软件，并为其提供接口和服务。
    是软件系统的核心，是各种软件的基础运行平台
    
    通用OS对共性功能提供支持，与硬件相关但同应用领域无关，所以可以支持很多应用领域
    支撑软件和应用软件：只能通过OS来使用计算机系统的物理资源
    OS：实现资源管理机制，允许应用程序提供资源管理策略

在传统的计算机系统中，OS是指运行在核心态的、受硬件保护的软件，而在用户空间所运行的shell、window等模块虽然能够实现系统功能，但并不是OS的组成部分。

传统上被认为是OS核心的组件：文件系统、主存管理、设备管理等

随着客户-服务器结构OS的出现，传统上的OS核心的组件都被移至用户空间运行。

#####1.1.2 操作系统的资源管理技术

资源管理

    软硬件资源的分配、使用和回收

    从更高的层次来看，操作系统将物理计算机的功能加以扩展，使之成为接口好、功能强、效率高、易使用的计算机系统，而这只是概念和逻辑上的，不是真实的、物理上的，成为虚拟机或虚拟器。

    每个应用程序运行在自己的虚拟机上，在一台虚拟机上运行的程序称为“进程”。

    (1)资源复用

        多道程序设计是现代OS采用的基本技术，系统中相应地有多个进程竞争使用资源。

        OS让众多进程共享物理资源，这种共享称为资源复用

        物理资源的复用有两种基本方法：空分复用共享，时分复用共享

        [1]空分复用共享(space-multiplexed sharing)

            表明资源可以进一步分割成更多和更小的单位供进程使用

            在计算机系统中，进程能够空分复用那些满足一下属性的物理资源，即能够将资源的不同单位同时分配给不同的进程

            主存和辅助存储器(磁盘)资源是空分复用共享的例子

        [2]时分复用共享(time-multiplexed sharing)

            并非将资源进一步分割成更小的单位，这类资源也不能被分割成更小的单位；反之，进程可以在一个时间片内以独占方式使用整个物理资源，其他进程则在另外的时间片内使用此资源。
            
            磁带机和处理器均采用时分复用共享技术管理

        进程能够空分复用主存资源，不同的进程映像装入不同的主存区域，拥有各自的地址空间，且通过硬件存储保护机制进行隔离。OS必须跟踪当前执行进程，确定其执行时间；而时分复用共享使得处理器可以执行已装入不同地址空间中的程序代码。这种共享硬件的技术称为多道程序设计。

    (2)资源虚化

        虚化又称虚拟性，是指OS中的一类有效的资源管理技术，能进一步提高OS为用户服务的能力和水平

        虚化的本质是对资源进行转化、模拟或整合，把一个物理资源转变成逻辑上的多个对应物，创建无须共享的多个独占资源的假象，以达到多用户共享一套计算机物理资源的目的。

        空分复用与虚化的比较：

            空分复用：分割的是实际存在的物理资源
            虚化：实现假想的虚拟同类资源

        采用虚化技术不但可以解决某类物理资源数量不足的问题，而且能够为应用程序提供更易于使用、高效的虚拟资源并创建更好的运行环境
        (如基于物理内存的虚拟内存)

        虚化技术可用于外部设备，应用程序把组织成文件形式的输出信息写至虚拟打印机，而不是直接与物理打印机交互，当输出信息全部汇集后，才被传送到物理打印机上打印，这样就不会发生进程阻塞。
        这种虚化技术称为外部设备同时联机操作(Simultaneous Peripheral Operations On Line, SPOOLing),它将物理上的一台独占设备转化成逻辑上的多台虚拟独占设备，多个进程可以并行“打印”

        虚化技术也可用于文件系统，就是虚拟文件系统(Virtual File System, VFS),使得在一个OS的控制下可以同时支持多种具体的文件系统。

        从本质上来看，SPOOLing技术、窗口技术、时分信道多路复用技术都建立在时分复用共享的基础上；
        虚拟存储器则是通过虚拟存储技术把物理上的多级存储器(主存和辅助存储器)映射为逻辑上的、单一的(虚拟)存储器，与频分信道多路复用技术一样都是建立在空分复用共享基础上


    (3)资源抽象

        资源复用和资源虚化的主要目标是解决物理资源数量不足的问题
        资源抽象则用于处理系统的复杂性，重点解决资源的易用性


操作系统中的基础抽象——进程、虚存和文件

    (1)进程抽象

    (2)虚存抽象

    (3)文件抽象

虚拟计算机

#####1.1.3 操作系统的作用与功能

#####1.1.4 操作系统的主要特性



##1.2 操作系统的形成与发展

###1.2.1 人工操作阶段

###1.2.2 管理程序阶段

###1.2.3 多道程序设计与操作系统的形成

###1.2.4 操作系统的发展和分类



##1.3 操作系统的基本服务和用户接口

###1.3.1 基本服务和用户接口

###1.3.2 程序接口与系统调用

###1.3.3 作业接口与操作命令



##1.4 操作系统结构和运行模型

###1.4.1 操作系统的构件和结构

###1.4.2 操作系统的运行模型

###1.4.3 Windows 2003 客户-服务器结构



##1.5 流行操作系统简介

###1.5.1 Windows 操作系统

###1.5.2 UNIX操作系统家族

###1.5.3 自由软件和Linux操作系统

###1.5.4 IBM系列操作系统

###1.5.5 其他流行操作系统



##1.6 本章小结



##习题一








#第二章 处理器管理

##2.1 中央处理器

###2.1.1 处理器

###2.1.2 程序状态字



##2.2 中断技术

###2.2.1 中断概念

###2.2.2 中断源分类

###2.2.3 中断和异常的响应及服务

###2.2.4 中断事件处理

###2.2.5 中断优先级和多重中断

###2.2.6 Linux中断处理

###2.2.7 Windows 2003中断处理



##2.3 进程及其实现

###2.3.1 进程的定义和属性

###2.3.2 进程的状态和转换

###2.3.3 进程的描述和组成

###2.3.4 进程切换与模式切换

###2.3.5 进程的控制和管理



##2.4 线程及其实现

###2.4.1 引入多线程的动机

###2.4.2 多线程环境中的进程和线程

###2.4.3 线程的实现



##2.5 Linux进程与线程




##2.6 Windows 2003 进程与线程



##2.7 处理器调度

###2.7.1 处理器调度的层次

###2.7.2 选择调度算法的原则

###2.7.3 作业和进程的关系

###2.7.4 作业的管理与调度



##2.8 处理器调度算法

###2.8.1 低级调度的功能和类型

###2.8.2 作业调度和低级调度算法

###2.8.3 实时调度算法

###2.8.4 多处理机调度算法



##2.9 Linux调度算法

###2.9.1 Linux传统调度算法

###2.9.2 Linux2.6调度算法



##2.10 Windows 2003 调度算法




##2.11 本章小结




##习题二








#第三章 同步、通信与死锁

##3.1 并发进程

###3.1.1 顺序程序设计

###3.1.2 进程的并发性

###3.1.3 进程的交互：协作和竞争



##3.2 临界区管理

###3.2.1 互斥和临界区

###3.2.2 临界区管理的尝试

###3.2.3 实现临界区管理的软件算法

###3.2.4 实现临界区管理的硬件设施



##3.3 信号量与PV操作

###3.3.1 同步和同步机制

###3.3.2 信号量与PV操作

###3.3.3 信号量实理互斥

###3.3.4 信号量解决5位哲学家吃通心面问题

###3.3.5 信号量解决生产者-消费者问题

###3.3.6 信号量解决读者-写者问题

###3.3.7 信号量解决理发师问题



##3.4 管程

###3.4.1 管程和条件变量

###3.4.2 管程的实现

###3.4.3 使用管程解决进程同步问题



##3.5 进程通信

###3.5.1 信号通信机制

###3.5.2 管道通信机制

###3.5.3 共享主存通信机制

###3.5.4 消息传递通信机制



##3.6 死锁

###3.6.1 死锁产生

###3.6.2 死锁防止

###3.6.3 死锁避免

###3.6.4 死锁检测和解除




##3.7 Linux同步机制和通信机制

###3.7.1 Linux内核同步机制

###3.7.2 System V IPC机制



##3.8 Windows 2003 同步机制和通信机制



##3.9 本章小结



##习题三








#第四章 存储管理

##4.1 存储器

###4.1.1 存储器的层次

###4.1.2 地址转换与存储保护



##4.2 连续存储空间管理

###4.2.1 固定分区存储管理

###4.2.2 可变分区存储管理

###4.2.3 伙伴系统

###4.2.4 主存不足的存储管理技术



##4.3 分页存储管理

###4.3.1 分页存储管理的基本原理

###4.3.2 快表

###4.3.3 分页存储空间的分配和去配

###4.3.4 分页存储空间的页面共享和保护

###4.3.5 多级页表

###4.3.6 反量页表



##4.4 分段存储管理

###4.4.1 程序的分段结构

###4.4.2 分段存储管理的基本原理

###4.4.3 段的共享和保护

###4.4.4 分段和分页的比较



##4.5 虚拟存储管理

###4.5.1 虚拟存储器的概念

###4.5.2 请求分页虚拟存储管理

###4.5.3 请求分段虚拟存储管理

###4.5.4 请求段页式虚拟存储管理



##4.6 Intel x86 分段和分页存储结构



##4.7 Linux虚拟存储管理

###4.7.1 Linux虚拟存储管理概述

###4.7.2 存储管理数据结构

###4.7.3 主存页框调度

###4.7.4 进程虚存空间映射

###4.7.5 缺页异常处理



##4.8 Windows 2003 虚拟存储管理

###4.8.1 主存管理的功能和地址空间布局

###4.8.2 进程主存空间分配

###4.8.3 主存管理的实现



##4.9 本章小结



##习题四








#第五章 设备管理

##5.1 I/O硬件原理

###5.1.1 I/O系统

###5.1.2 I/O控制方式

###5.1.3 设备控制器



##5.2 I/O软件原理

###5.2.1 I/O软件的设计目标和原则

###5.2.2 I/O中断处理程序

###5.2.3 I/O设备驱动程序

###5.2.4 独立于设备的I/O软件

###5.2.5 用户空间的I/O软件



##5.3 具有通道的I/O系统

###5.3.1 通道命令和通道程序

###5.3.2 I/O指令和主机I/O程序

###5.3.3 通道启动和I/O操作过程



##5.4 缓冲技术

###5.4.1 单缓冲

###5.4.2 双缓冲

###5.4.3 多缓冲

###5.4.4 缓冲区高速缓存



##5.5 驱动调度技术

###5.5.1 存储设备的物理结构

###5.5.2 循环排序

###5.5.3 优化分布

###5.5.4 搜查定位

###5.5.5 独立磁盘冗余阵列

###5.5.6 提高磁盘I/O速度的方法



##5.6 设备分配

###5.6.1 设备独立性

###5.6.2 设备分配和设备分配数据结构



##5.7 虚拟设备

###5.7.1 问题的提出

###5.7.2 SPOOLing的设计与实现

###5.7.3 SPOOLing应用



##5.8 Linux设备管理

###5.8.1 设备管理概述

###5.8.2 设备驱动程序

###5.8.3 设备I/O的处理



##5.9 Windows 2003 I/O系统

###5.9.1 I/O系统结构和组件

###5.9.2 I/O系统数据结构

###5.9.3 I/O类型和处理

###5.9.4 高速缓存管理



##5.10 本章小结



##习题五








#第六章 文件管理

##6.1 文件

###6.1.1 文件概念

###6.1.2 文件命名

###6.1.3 文件类型

###6.1.4 文件属性

###6.1.5 文件存取方法



##6.2 文件目录

###6.2.1 文件控制块、文件目录与目录文件

###6.2.2 层次目录结构

###6.2.3 文件目录的检索



##6.3 文件组织与数据存储

###6.3.1 文件的存储

###6.3.2 文件的逻辑结构

###6.3.3 文件的物理结构



##6.4 文件系统其他功能的实现

###6.4.1 文件系统调用的实现

###6.4.2 文件共享

###6.4.3 文件空间管理

###6.4.4 主存映射文件

###6.4.5 虚拟文件系统



##6.5 Linux文件系统

###6.5.1 Linux虚拟文件系统

###6.5.2 文件系统的注册与注销及安装与卸载

###6.5.3 文件系统的缓存机制

###6.5.4 Ext2文件系统



##6.6 Windows 2003 文件系统

###6.6.1 文件系统概述

###6.6.2 NTFS在磁盘上的结构

###6.6.3 文件系统模型和FSD体系结构

###6.6.4 NTFS可恢复性支持

###6.6.5 NTFS安全性支持



##6.7 本章小结




##习题六








#第七章 操作系统的安全与保护

##7.1 安全性概述



##7.2 安全策略

###7.2.1 安全需求和安全策略

###7.2.2 访问支持策略

###7.2.3 访问控制策略



##7.3 安全模型

###7.3.1 安全模型概述

###7.3.2 安全模型示例



##7.4 安全机制

###7.4.1 硬件安全机制

###7.4.2 认证机制

###7.4.3 授权机制

###7.4.4 加密机制

###7.4.5 审计机制



##7.5 安全操作系统设计和开发

###7.5.1 安全操作系统的结构和设计原则

###7.5.2 安全操作系统的开发

###7.5.3 信息系统安全评价标准简介



##7.6 Linux安全机制



##7.7 Windows 2003 安全机制

###7.7.1 安全性组件和安全登录

###7.7.2 访问控制

###7.7.3 安全审计

###7.7.4 加密文件系统



##7.8 本章小结




##习题七








#第八章 网络和分布式操作系统

##8.1 计算机网络概述

###8.1.1 计算机网络的概念

###8.1.2 网络体系结构



##8.2 网络操作系统

###8.2.1 网络操作系统概述

###8.2.2 网络操作系统实例



##8.3 分布式操作系统

###8.3.1 分布式系统概述

###8.3.2 分布式进程通信

###8.3.3 分布式资源管理

###8.3.4 分布式进程同步

###8.3.5 分布式系统中的死锁

###8.3.6 分布式文件系统

###8.3.7 分布式进程迁移



##8.4 Linux网络体系结构



##8.5 Windows 2003 网络体系结构和网络服务



##8.6 本章小结



##习题八








#参考文献
