# 第4章 树

二叉查找树的大部分操作的运行时间平均为$O(logN)$

- 了解树是如何用于实现几个流行的操作系统中的文件系统的
- 了解树如何用来计算算术表达式的值
- 指出如何利用树支持以$O(logN)$平均时间进行的各种搜索操作，以及如何细化以得到最坏情况时间界$O(logN)$。还将讨论当数据被存放在磁盘上时如何实现这些操作
- 讨论并使用set和map类

## 4.1 预备知识

树的递归定义：一棵树是一些结点的集合。这个集合可以是空集；若不是空集，则树由**根**结点$r$以及零或多个非空的（子）树$T_1,T_2,\cdots,T_k$组成，这些子树中每一棵的根都被来自根$r$的一条有向的**边**所连接。每一棵子树的根叫做根$r$的**儿子**，而$r$是每一棵子树的根的**父亲**

一棵树是N个结点和N-1条边的结合，其中的一个结点叫做根。每条边都将某个结点连接到它的父亲；而除去根节点外，每一个结点都有一个父亲

- 叶结点：没有儿子的结点
- 兄弟结点：具有相同父亲的结点
- 祖父
- 孙子
- 路径：从结点$n_1$到$n_k$的路径为结点$n_1,n_2,\cdots,n_k$的一个序列，使得对于$1\leq i<k$，结点$n_i$是$n_{i+1}$的父亲
- 路径的长度：路径上边的条数，即k-1 （从每一个结点到它自己有一条长为0的路径，在一棵树中从根到每个结点恰好存在一条路径）
- 深度：$n-i$的深度为从根到$n_i$唯一路径的长度 （根的深度为0）
- 高度：$n_i$的高度是从$n_i$到一片树叶的最长路径的长度 （所有的树叶的高度都是0，一棵树的高度等于它的根的高)
- 祖先/后裔：如果存在从$n_1$到$n_2$的一条路径，那么$n_1$是$n_2$的一个**祖先**，而$n_2$是$n_1$的一个**后裔**
- 真祖先/真后裔：如果$n_1\neq n_2$

### 4.1.1 树的实现

实现树的一个方法：将每个结点的所有儿子都放在树结点的链表中

```c++
struct TreeNode
{
	Object element;
	TreeNode *firstChild;
	TreeNode *nextSibling;
};
```

典型的声明

### 4.1.2 树的遍历及应用

## 4.2 二叉树

## 4.3 查找树ADT——二叉查找树

## 4.4 AVL树

## 4.5 伸展树

## 4.6 树的遍历

## 4.7 B树

## 4.8 标准库中的set和map